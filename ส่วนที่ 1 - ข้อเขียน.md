# ข้อสอบคัดเลือก Full Stack Developer
## ส่วนที่ 1 — ข้อเขียน

### 1. อธิบายลำดับการทำงานใน NestJS: CORS → Middleware → Guard → Interceptor → Controller → Service

**ลำดับการทำงาน:**

1. **CORS (Cross-Origin Resource Sharing)**
   - **ใช้เพื่อ**: อนุญาตให้ frontend จาก domain อื่นเรียก API ได้
   - **จุดประสงค์**: แก้ปัญหา same-origin policy ของเบราว์เซอร์
   - **ตัวอย่าง**: `app.enableCors({ origin: 'http://localhost:3000' })`

2. **Middleware**
   - **ใช้เพื่อ**: ประมวลผล request ก่อนส่งต่อไปยัง route handler
   - **จุดประสงค์**: Logging, Authentication, Request parsing, Rate limiting
   - **ตัวอย่าง**: Request ID middleware, Body parser, Logger middleware

3. **Guard**
   - **ใช้เพื่อ**: ตรวจสอบสิทธิ์การเข้าถึง (Authorization & Authentication)
   - **จุดประสงค์**: ป้องกัน unauthorized access
   - **ตัวอย่าง**: JWT Guard, Role Guard, API Key Guard

4. **Interceptor**
   - **ใช้เพื่อ**: แปลงข้อมูล request/response, logging, caching
   - **จุดประสงค์**: AOP (Aspect-Oriented Programming)
   - **ตัวอย่าง**: Transform response, Timeout handling, Cache interceptor

5. **Controller**
   - **ใช้เพื่อ**: รับ HTTP request และส่งคืน response
   - **จุดประสงค์**: Handle routing และ validation
   - **ตัวอย่าง**: `@Get()`, `@Post()`, `@Body()`, `@Param()`

6. **Service**
   - **ใช้เพื่อ**: Business logic และการเชื่อมต่อ database
   - **จุดประสงค์**: แยก business logic จาก controller
   - **ตัวอย่าง**: UserService, EmailService, DatabaseService

---

### 2. ความต่าง Middleware vs Guard ใน NestJS และตัวอย่างกรณีใช้งาน

| **Middleware** | **Guard** |
|---|---|
| ทำงานก่อน route handler | ทำงานหลัง middleware แต่ก่อน controller |
| สามารถเรียก `next()` หรือหยุดการทำงาน | คืนค่า `true`/`false` เท่านั้น |
| เข้าถึง `request`, `response`, `next` | เข้าถึง `ExecutionContext` |
| ใช้สำหรับ general processing | ใช้เฉพาะ authorization/authentication |

**ตัวอย่างการใช้งาน:**

**Middleware:**
```typescript
// ใช้สำหรับ logging, parsing, CORS
@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log(`${req.method} ${req.originalUrl}`);
    next();
  }
}
```

**Guard:**
```typescript
// ใช้สำหรับตรวจสอบ JWT token
@Injectable()
export class JwtAuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const token = request.headers.authorization;
    return this.validateToken(token);
  }
}
```

---

### 3. แนวทาง JWT เบื้องต้น

**โครงสร้าง JWT Token:**
```
Header.Payload.Signature
```

- **Header**: อัลกอริธึมการเข้ารหัส (เช่น HS256, RS256)
- **Payload**: ข้อมูลผู้ใช้ (user id, email, role, exp)
- **Signature**: ลายเซ็นป้องกันการปลอมแปลง

**ที่มาของ Secret:**
- **Symmetric**: ใช้ secret key เดียวกันทั้ง sign และ verify
- **Asymmetric**: ใช้ private key ในการ sign และ public key ในการ verify
- **เก็บใน**: Environment variables, Key management service

**อายุใช้งาน:**
- **Access Token**: สั้น (15 นาที - 1 ชั่วโมง)
- **Refresh Token**: ยาว (7-30 วัน)

**Refresh Token คือ:**
- Token พิเศษสำหรับขอ access token ใหม่
- ใช้เมื่อ access token หมดอายุ
- มีอายุยาวกว่า access token
- เก็บใน database เพื่อสามารถ revoke ได้

---

### 4. แก้ CORS ระหว่าง Frontend กับ NestJS

**วิธีแก้ CORS:**
```typescript
// ใน main.ts
app.enableCors({
  origin: ['http://localhost:3000', 'http://localhost:5173'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'x-request-id'],
  exposedHeaders: ['x-request-id']
});
```

**Header สำคัญ:**
- **Access-Control-Allow-Origin**: กำหนด domain ที่อนุญาต
- **Access-Control-Allow-Methods**: HTTP methods ที่อนุญาต
- **Access-Control-Allow-Headers**: Headers ที่อนุญาตใน request
- **Access-Control-Allow-Credentials**: อนุญาตส่ง cookies/authorization
- **Access-Control-Expose-Headers**: Headers ที่ frontend เข้าถึงได้

---

### 5. ทำไมควรมี Request ID และการ Log Tracing

**ประโยชน์ของ Request ID:**
1. **Traceability**: ตามรอยการทำงานของ request เดียวได้ตลอด lifecycle
2. **Debugging**: แก้ bug ง่ายขึ้นเมื่อมี error ใน production
3. **Monitoring**: วิเคราะห์ performance และ bottleneck
4. **Audit Trail**: ตรวจสอบการเข้าถึงระบบ

**วิธีการ Log:**
```typescript
// Middleware สำหรับ Request ID
@Injectable()
export class RequestIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const requestId = req.headers['x-request-id'] || uuidv4();
    req.id = requestId;
    res.setHeader('x-request-id', requestId);
    
    // Log เข้า
    console.log(`[${requestId}] ${req.method} ${req.originalUrl} - START`);
    
    // Log ออก
    res.on('finish', () => {
      console.log(`[${requestId}] ${req.method} ${req.originalUrl} - ${res.statusCode} - END`);
    });
    
    next();
  }
}
```

**Best Practices:**
- ใช้ UUID v4 สำหรับ Request ID
- ส่ง Request ID กลับใน response header
- Log ทั้ง request เข้าและออก
- เก็บ Request ID ใน error logs
- ส่งต่อ Request ID ไปยัง external services