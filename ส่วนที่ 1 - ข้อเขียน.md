# ข้อสอบคัดเลือก Full Stack Developer
## ส่วนที่ 1 — ข้อเขียน

### 1. อธิบายลำดับการทำงานใน NestJS: CORS → Middleware → Guard → Interceptor → Controller → Service

ใน NestJS จะมีลำดับการทำงานที่ชัดเจนครับ โดยเริ่มจาก:

**1. CORS** - เช็คว่า request มาจาก domain ไหน อนุญาตหรือไม่  
**2. Middleware** - ทำงานประมวลผลเบื้องต้น เช่น parse body, logging  
**3. Guard** - เช็ค authentication และ authorization  
**4. Interceptor** - แปลงข้อมูล request/response หรือเพิ่ม logic พิเศษ  
**5. Controller** - รับ request และเรียก service  
**6. Service** - ประมวลผล business logic และติดต่อ database  

ปล.ถ้าขั้นไหนไม่ผ่านก็จะหยุดทันที ไม่ส่งต่อไปขั้นถัดไปครับ


==============================================================================



### 2. ความต่าง Middleware vs Guard ใน NestJS และตัวอย่างกรณีใช้งาน

**Middleware** ทำงานก่อน Guard และสามารถเปลี่ยนแปลง request/response ได้ เช่น เพิ่ม header, parse body  
**Guard** ทำงานหลัง Middleware และเฉพาะเจาะจงเรื่อง authentication เท่านั้น return แค่ true/false

```javascript
// Middleware - ใช้เพิ่ม request ID
export class RequestIdMiddleware {
  use(req, res, next) {
    req.id = uuid();
    next();
  }
}

// Guard - ใช้เช็ค JWT token  
export class AuthGuard {
  canActivate(context) {
    const req = context.switchToHttp().getRequest();
    return this.jwtService.verify(req.headers.authorization);
  }
}
```


==============================================================================



### 3. แนวทาง JWT เบื้องต้น

**JWT** ย่อมาจาก JSON Web Token เป็นการเก็บข้อมูลแบบ stateless  
รูปแบบ: `header.payload.signature`

- **Header**: เก็บ algorithm ที่ใช้ sign (HS256, RS256)
- **Payload**: เก็บข้อมูลผู้ใช้ เช่น user_id, email, role, expire time
- **Signature**: ป้องกันไม่ให้ใครแก้ไขข้อมูล

**Secret ได้มาจากไหน?**  
สร้างเอง แบบ random string ยาวๆ เก็บใน environment variable

**อายุใช้งาน:**  
- Access token: สั้น (15-30 นาที) เพื่อความปลอดภัย  
- Refresh token: ยาว (7-30 วัน) สำหรับขอ access token ใหม่  

**Refresh Token:**  
คือ token พิเศษที่ใช้ขอ access token ใหม่เมื่อหมดอายุ เก็บใน database เพื่อสามารถยกเลิกได้


==============================================================================


### 4. แก้ CORS ระหว่าง Frontend กับ NestJS

CORS เกิดจากเบราว์เซอร์บล็อกไม่ให้ website หนึ่งเรียก API จาก domain อื่น

**แก้ใน NestJS:**
```javascript
// main.ts
app.enableCors({
  origin: 'http://localhost:3000', 
  credentials: true,
  allowedHeaders: ['Content-Type', 'Authorization', 'x-request-id']
});
```

**Headers สำคัญ:**
- `Access-Control-Allow-Origin`: บอกว่าอนุญาต domain ไหน
- `Access-Control-Allow-Methods`: อนุญาต HTTP method ไหน  
- `Access-Control-Allow-Headers`: อนุญาต header ไหนใน request
- `Access-Control-Expose-Headers`: header ไหนที่ frontend เอาไปใช้ได้


==============================================================================



### 5. ทำไมควรมี Request ID และการ Log Tracing

**Request ID** คือ unique identifier ที่ติดไปกับ request นั้นตลอด lifecycle

**ประโยชน์:**
- **Debug ง่าย**: เมื่อเกิด error สามารถตามรอย request นั้นได้ตั้งแต่เข้าจนออก
- **Performance monitoring**: วิเคราะห์ว่า request ไหนช้า bottleneck ตรงไหน
- **Audit trail**: เก็บหลักฐานการเข้าใช้ระบบ

**วิธีทำ:**
```javascript
// สร้าง middleware เพื่อเพิ่ม request ID
export class RequestIdMiddleware {
  use(req, res, next) {
    const requestId = req.headers['x-request-id'] || generateUuid();
    req.requestId = requestId;
    res.setHeader('x-request-id', requestId);
    
    console.log(`[${requestId}] ${req.method} ${req.path} - START`);
    next();
  }
}
```

ควรส่ง request ID ไปทุก service ที่เกี่ยวข้องครับ และเพิ่ม log ทั้งขาเข้าและขาออกด้วย